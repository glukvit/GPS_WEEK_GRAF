#!/usr/bin/env python3
#Cкрипт который будет строить набор графиков временных рядов.
#pos-файлы которые попадут в обработку должны находиться в папке указанной в переменной  temp_dir там и будет происходить обработка.
'''
    Скрипт требует установки пакета ImageMagic с помощью которого осуществляется обрезка
    готовых растровых изображений графиков. Можно обойтись и без установки ImageMagic,
    в таком случае необходимо закоментировать процедуру cutting и если потребуется выполнять
    обрезку изображений вручную, например в графических или текстовых редакторах.
    Список станций для построения графиков находится в файле конфига
''' 
import paramiko #импорт модуля для ssh соедиения
import os #импорт модуля для работы с файловой системой
import shutil #модуль для работы с файловой системой и рекурсивного удаления содержимого директорий
import subprocess #импорт модуля для работы с процессами и запуском команд в shell
import glob #импорт модуля для фильтрации файлов в каталоге
import matplotlib.pyplot as plt #импорт модуля matplotlib для создания графиков
import matplotlib.dates as mdates
import matplotlib.dates
import numpy
import numpy as np
import pylab

matrix=np.array([]) #Переменная в которую будет записываться текущая обрабатываемая матрица
 
conf_path="/home/gluk/config" #Путь до директории с файлом конфига
conf_fl="graf_list.txt" #Файл конфига
temp_dir="/home/gluk/temp"# Папка для обработки здесь будут храниться .pos файлы и куча временного мусора"

def chcd(tm):		#Процедура смены текущей директории.
    os.chdir(tm) #Меняем текущую директорию

def lscmd(): #Процедура считывания списка файлов
    outfiles=[]#Список для pos файлов
    outfiles=glob.glob('*.pos')#Фильтруем файлы по расширению.(можно по шаблону)
    result=ls_graf1() #Получаем список содержащий перечень станций из конфиг файла
    grf=list(set(result) & set(outfiles)) #Получаем список станций которые пойдут в обработку
    return(grf) # процедура возвращает переменную со списком станций

def openfl(rs): #Процедура открытия и чтения pos-файлов 
    for every in rs: 
	    infile=open(every,'r')	#Открываем файл 
	    i=1 #Счетчик для пропуска строк
	    while i<37:		#Запускаем счетчик для пропуска строк шапки.
		    line=infile.readline()	#Просто прочитываем строки ничего не делая.
		    i=i+1 #Увеличиваем счетчик
	    outfile=open(every+'.out','w')	#Создаем выходной файл в который запишем дату и смещение
	    while line:		#перебираем оставшиеся строки файла
		    try:	#Без try цикл дает ошибку IndexError с try все вроде работает нормально.Но надо будет проверить!!!!!!!!!
		        line=infile.readline()	#читаем построчно
		        data=line.split()		#разделяем строки на отдельные слова.
		        solt=data[0]+' '+data[2]+' '+data[15]+' '+data[16]+' '+data[17]+' '+data[18]+' '+data[19]+' '+data[20] #выбираем из слов данные с датой, юлианским временем и смещением dN и dE и три столбца сигма 
		        outfile.writelines(solt+'\n') #Пишем данные в выходной файл.
		    except IndexError:
		        pass #Ну происходит ошибка а мы ничего делать не будем. Ибо данные на месте.
	    outfile.close() #Закрываем выходной файл с записанными данными.

def fifil():	#Фильтр файлов в каталоге по расширению.
    curd=(os.getcwd()) #Определяем текущую директорию
    files = os.listdir(curd) #Получаем список файлов в директории
    outfiles=glob.glob('*.out')	#Фильтруем файлы по расширению.(можно по шаблону)
    return(outfiles) #Процедура возращает список файлов с расширением .out эти файлы содержат дату  и смещение dN и dE для каждой станции.
        
def prep(plist):	#Процедура подготовки данных
    time=[] #Список куда запишем время
    mtime=[]#Список куда будем вставлять даты переведенные с помощью mdates.datestr2num для того чтобы в matplotlib смог корректно отображать времяю Пока не ясно может быть не нужно.!!!!!
    Jtime=[]#Список куда запишем юлианское привденное время. Будем его использовать для всех расчетов.
    dN=[] #Список куда запишем dN
    dE=[] #Список куда запишем dE
    dU=[] #Список куда запишем dU
    Sn=[] #Список куда запишем сигма для N
    Se=[] #Список куда запишем сигма для E
    Su=[] #Список куда запишем сигма для U
    for every in plist:	#Перебираем файлы по списку.    
	    infile=open(every, 'r')#Открываем файл 
	    st_name_matrx=every #st_name_matrx переменная передающая имя открытого файла для сохранения готовой матрицы процедурой matrix_save
	    line=infile.readline() #Читаем файл построчно
	    while line: #Пока есть строки перебираем их
		    try:    
		        line=infile.readline()#читаем построчно
		        data=line.split()#разделяем строки на отдельные слова.
		        tm=data[0] #Из столбца 0. Выделяем время для подписывания графиков. Следующие три строчки преобразование даты для matplotlib
		        time.append(float(data[0])) # Пришлось сделать дату float иначе полученная матрица не обрабатывается.
		        gtime=mdates.datestr2num(tm) #Преобразованную дату переводим в с помощью datestr2num в формат понятный matplotlib
		        mtime.append(gtime) #Переведенные даты добавляем в список который используется как даты при построении графиков
		        Jtime.append(float(data[1])) #юлианское приведеное время
		        dN.append(float(data[2])) #dN из столбца 2
		        dE.append(float(data[3])) #dE из столбца 3
		        dU.append(float(data[4])) #dU из столбца 4
		        Sn.append(float(data[5])) #Sn из столбца 5
		        Se.append(float(data[6])) #Se из столбца 6
		        Su.append(float(data[7])) #Sn из столбца 7
		    except IndexError:
		        pass #Ну происходит ошибка а мы ничего делать не будем. Ибо данные на месте.
	    infile.close()
	    mx=math(dN,dE,dU,Sn,Se,Su,Jtime,mtime,time) #Прикручиваем математику и передаем ее переменной для сохранения готовой матрицы
	    matrix_save(st_name_matrx,mx)# Процедура сохранения матриц. st_name_matrx переменная с именем файла,mx сохраняемая матрица 
	    time=[] #Очищаем списки
	    mtime=[]#Очищаем списки
	    Jtime=[]#Очищаем списки
	    dN=[] #Очищаем списки
	    dE=[] #Очищаем списки
	    dU=[]#Очищаем списки
	    Sn=[] #Очищаем списки
	    Se=[] #Очищаем списки
	    Su=[] #Очищаем списки
#    return(dN,dE,dU,time,mtime) #
    return()
def math(N,E,U,sn,se,su,Jt,mt,t):#Математика. Фильтр грубых ошибок. Удаление тренда. Медиана.
    # Надо как то переписать ввиде цикла(ов)
    matrix=np.array([t,mt,Jt,E,N,U,se,sn,su]) #Создаем матрицу из данных для удобства работы
    matrix=matrix.transpose()#Транспонируем
    med_se=numpy.median(se)#Считаем среднее значение, медиану для cигмы Se
    med_sn=numpy.median(sn)#Считаем среднее значение, медиану для cигмы Sn
    med_su=numpy.median(su)#Считаем среднее значение, медиану для cигмы Su
    dEerr=3*med_se # Максимальная ошибка для dE
    dNerr=3*med_sn # Максимальная ошибка для dN
    dUerr=3*med_su # Максимальная ошибка для dU
    print('до первого фильтра',matrix.shape)
    #Следующие шесть строк фильтр грубых ошибок (Первый фильтр)
    ind=np.where(matrix[:,3]>dEerr) #Выбираем в столбце E [3] строки в которых отсчет превышает маскимальную ошибку. ind содержит индексы этих элементов.
    matrix=np.delete(matrix,ind[0],0) #Удаляем из матрицы строки содержащие ошибку в dE 
    ind=np.where(matrix[:,4]>dNerr) #Выбираем в столбце N [4] строки в которых отсчет превышает маскимальную ошибку. ind содержит индексы этих элементов.
    matrix=np.delete(matrix,ind[0],0) #Удаляем из матрицы строки содержащие ошибку в dN
    ind=np.where(matrix[:,5]>dUerr) #Выбираем в столбце U [5] строки в которых отсчет превышает маскимальную ошибку. ind содержит индексы этих элементов.
    matrix=np.delete(matrix,ind[0],0) #Удаляем из матрицы строки содержащие ошибку в dU
    print('после первого фильтра',matrix.shape)
    #Фильтр ошибок после детрендирования ряда.(Второй фильтр)

    #Фильтруем по dE
    modelE = numpy.polyfit(matrix[:,2],matrix[:,3],1) #Считаем коэффициенты полинома для dE для определения тренда.!!!! ЕСЛИ ВМЕСТО Jt подставить mt??????????
    Epredicted=np.zeros((matrix.shape[0],1)) #Объявляем матрицу для данных тренда. Количество строк равно количеству строк в matrix, кол-во столбцов 1
    Epredicted= numpy.polyval(modelE,matrix[:,2]) #Считаем тренд для dE 
    E_detrend=np.zeros((matrix.shape[0],1))#Объявляем матрицу в которую запишем данные после детренда по dE.Количество строк равно количеству строк в matrix, кол-во столбцов 1
    E_detrend_1=np.zeros((matrix.shape[0],1)) #Временная матрица используется только для подсчета ошибки!!!
    E_detrend[:,0]=(matrix[:,3]-Epredicted) #Делаем детренд
    E_detrend_1[:,0]=abs(E_detrend[:,0]) #Берем модуль от значений детрендированного ряда
    med_dEdetr=np.median(E_detrend_1[:,0])#Медиана модуля детрендированного ряда
    dEerr2=4.5*med_dEdetr #Максимальная ошибка второго фильтра по dE
    print('До добавления по dE',np.shape(matrix))
    matrix=np.append(matrix,E_detrend,axis=1) #Добавляем столбец в matrix c детрендированным и взятым по модулю dE !!! РАЗОБРАТЬСЯ В ЗАПИСИ И ПОНЯТь ЧТО ПОДСТАВЛЯЕТСЯ В ГРАФИКИ!!!
    print('После добавления по dE',np.shape(matrix))
    ind2=np.where(abs(matrix[0:,9])>dEerr2)
    matrix=np.delete(matrix,ind2[0],0) #Удаляем ошибки по dE
    print('после второго фильтра по dE',matrix.shape)
    #Фильтруем по dN

    modelN = numpy.polyfit(matrix[:,2],matrix[:,4],1) #Считаем коэффициенты полинома для dN для определения тренда.
    Npredicted=np.zeros((matrix.shape[0],1)) #Объявляем матрицу для данных тренда. Количество строк равно количеству строк в matrix, кол-во столбцов 1 
    Npredicted= numpy.polyval(modelN,matrix[:,2]) #Считаем тренд для dN
    N_detrend=np.zeros((matrix.shape[0],1))#Объявляем матрицу в которую запишем данные после детренда по dN.
    N_detrend_1=np.zeros((matrix.shape[0],1)) #Временная матрица используется только для подсчета ошибки!!!
    N_detrend[:,0]=(matrix[:,4]-Npredicted) #Делаем детренд
    N_detrend_1[:,0]=abs(N_detrend[:,0]) #Берем модуль от значений детрендированного ряда
    med_dNdetr=np.median(N_detrend_1[:,0]) #Медиана детрендированного ряда
    dNerr2=4.5*med_dNdetr #Максимальная ошибка второго фильтра по dN Текущее!!!
    print('До добавления по dN',np.shape(matrix))
    matrix=np.append(matrix,N_detrend,axis=1) #Добавляем столбец в matrix c детрендированным и взятым по модулю dN
    print('После добавления по dN',np.shape(matrix))
    ind3=np.where(abs(matrix[0:,10])>dNerr2)
    matrix=np.delete(matrix,ind3[0],0) #Удаляем ошибки по dN
    print('второго фильтра по dN',matrix.shape)

    #Фильтруем по dU
    modelU = numpy.polyfit(matrix[:,2],matrix[:,5],1) #Считаем коэффициенты полинома для dU для определения тренда
    Upredicted=np.zeros((matrix.shape[0],1)) #Объявляем матрицу для данных тренда.
    Upredicted= numpy.polyval(modelU,matrix[:,2]) #Считаем тренд для dU
    U_detrend=np.zeros((matrix.shape[0],1))#Объявляем матрицу в которую запишем данные после детренда по dU
    U_detrend_1=np.zeros((matrix.shape[0],1))#Временная матрица используется только для подсчета ошибки!!!
    U_detrend[:,0]=(matrix[:,5]-Upredicted) #Делаем детренд
    U_detrend_1[:,0]=abs(U_detrend[:,0])#Берем модуль от значений детрендированного ряда
    med_dUdetr=np.median(U_detrend_1[:,0]) #Медиана детрендированного ряда Текущее!!!
    dUerr2=4.5*med_dUdetr #Максимальная ошибка второго фильтра по dU #Текущее!!!
    print('До добавления по dU',np.shape(matrix))
    matrix=np.append(matrix,U_detrend,axis=1) #Добавляем столбец в matrix c детрендированным и взятым по модулю dU
    print('После добавления по dU',np.shape(matrix))
    ind4=np.where(abs(matrix[0:,11])>dUerr2) #Берем индексы ячеек где содержатся ошибки данных
    matrix=np.delete(matrix,ind4[0],0)
    print('после второго фильтра по dU',matrix.shape)

    return(matrix)

def matrix_save(fl,xm): #Процедура записи готовой матрицы для каждой станции в файл 
    '''
    Можно было короче например:xm.tofile(fl+'.mx')
    Но с четким указанием разделителя и формата данных 
    нет случайных ошибок
    '''
    filename=fl+'.mx' #Присваиваем переменной имя текущей станции и с расширением.
    outfile=open(filename,'w')  #Открываем файл на запись
    xm.tofile(outfile,sep="",format="%f") #Записываем матрицу в файл
    xm=[]
    outfile.close #Закрываем файл.
    
def ls_graf(): #Процедура считывания списка станций из конфига.
    os.chdir(conf_path) #Переходим в каталог с конфигом путь в переменной
    txtt=open(conf_fl,'r') #Открываем файл с конфигом для чтения имя файла в переменной
    inside=txtt.readlines() #Читаем построчно
    lst=[] #Список для перечня станций
    for every in inside:
	    every=every[0:4] #Беремем из каждой строки первые четыре символа названия станции
	    every=every+'.kmch.pos.out.mx'#Прибавляем к этим символам необходимые расширения, чтобы потом подставить в строку стравнения
	    lst.append(every) #Добавляем в созданный список измененные названия станций.
#    inside.close() #Закрываем файл конфига
    os.chdir(temp_dir) #Снова переходим в рабочую директорию.
    return(lst)
def ls_graf1(): #Процедура считывания списка станций из конфига для того чтобы не считать лишние матрицы!!!!!!!!!! 
    os.chdir(conf_path) #Переходим в каталог с конфигом путь в переменной
    txtt=open(conf_fl,'r') #Открываем файл с конфигом для чтения имя файла в переменной
    inside=txtt.readlines() #Читаем построчно
    lst=[] #Список для перечня станций
    for every in inside:
	    print(every)
	    every=every[0:4] #Беремем из каждой строки первые четыре символа названия станции
	    every=every+'.kmch.pos'#Прибавляем к этим символам необходимые расширения, чтобы потом подставить в строку стравнения
	    lst.append(every) #Добавляем в созданный список измененные названия станций.
#    inside.close() #Закрываем файл конфига
    os.chdir(temp_dir) #Снова переходим в рабочую директорию.
    return(lst)
    
def mxopen():#Процедура построения графиков.
    curd=(os.getcwd()) #Определяем текущую директорию
    outfiles=[] #Список для файлов матриц mx
    outfiles=glob.glob('*.mx')#Фильтруем файлы по расширению.(можно по шаблону)
    print("список готовых для построения матриц:   ")
    print(sorted(outfiles))
    print(" ")
    result=ls_graf() #Получаем список содержащий перечень станций из конфиг файла
    print(" ")
    print("список станций указанных в config-файле:   ")
    print(sorted(result))
    grf=list(set(result) & set(outfiles)) #Сравниваем два списка список файлов матриц и список станций конфига. Все что имеется в обоих списках записываем в grf
    print(" ")
    print("данные станций используемых в построении графиков:  ")
    print(sorted(grf))
    print(" ")
    quantity=(len(grf))# Количество графиков исходя из количества .mx файлов
    fig, axes=plt.subplots(nrows=quantity, sharex=True, sharey=True) #Создаем рисунок nrows= количество строк, sharex=True, sharey=True одинаковые размеры по осям
    i=0 #Счетчик количества графиков
#Строим график dN
    for every in grf: #Перебираем элементы из переменной со списком файлов
	    off=np.fromfile(every, dtype=np.float) #Считываем матрицу из файла. В результате матрица получается в одну строку!
	    shp=off.shape[0] #Получаем количество элементов матрицы
	    cstr=int(shp/12) #Делим количество элементов на 12 столбцов получаем изначальное количество строк.После обновления numpy до версии 1.14.5 обязательно объявлять матрице размер типа int
	    c=int(12)# После обновления numpy до версии 1.14.5 обязательно объявлять матрице размер типа int
	    off.resize((cstr,c))
	    dt=off[:,0] #Используем отдельную матрицу для времени. Можно было использовать на прямую
	    dg=[] #Массив для измененных дат которые используются в матплотлиб
	    for el in dt.flat: #Цикл для создания дат формата 01, 12, 2016
		    data=(str(el)) #Переводим флоат матрицы в стринг
		    data=data.split() #Разбиваем стринг на элементы
		    tm=data[0] #Присваиваем переменной содержание данного элемента
		    elstr=tm[0:4]+' ,'+tm[4:6]+' ,'+tm[6:8] #Создаем из элемента дату в формате 01, 12, 2016
		    dg.append(elstr) # Добавляем элементы в массив. 
	    xdata_float = mdates.datestr2num(dg)#Обрабатываем массив через дейтстунум для построения графиков
	    axes[i].xaxis.set_major_formatter (mdates.DateFormatter("%Y:%m")) # Для текущего графика объявляем формат используемой даты
	    axes[i].plot_date(xdata_float, off[:,10], 'b.')#Построение текущего графика
	    axes[i].tick_params(axis='x', which='major',labelsize=18) # Размер шрифта цифр подписи даты
	    axes[i].grid(True)# Разграфка
	    xtxt=[] #Массив для получения начал координат текущего графика. Используется для нанесения названий станций
	    xtxt=plt.xlim() #Копируем начала координат графика в переменную. На прямую подставлять xlim в команды нельзя изменяются масштабы
	    disx=xtxt[0]+15 #Координата x для нанесения названия станции
	    axes[i].text(disx,0.002,every[0:4],fontsize=18)#Подписи графиков из имени файлов
	    i=i+1
    fig.subplots_adjust(hspace=0)#Расстояние между графиками.
    size=fig.get_size_inches() #Получаем размер картинки
    fig.set_size_inches(size[0]*3, size[1]*4.5) #Меняем размер картинки
    plt.ylabel("dN, m")
    plt.savefig('dN.png',format='png', dpi=250) #Сохраняем картинку
#Строим график dE
    fig, axes=plt.subplots(nrows=quantity, sharex=True, sharey=True) #Создаем рисунок nrows= количество строк, sharex=True, sharey=True одинаковые размеры по
    i=0 #Счетчик количества графиков
    for every in grf: #Перебираем элементы из переменной со списком файлов
	    off=np.fromfile(every, dtype=np.float) #Считываем матрицу из файла. В результате матрица получается в одну строку!
	    shp=off.shape[0] #Получаем количество элементов матрицы
	    cstr=int(shp/12) #Делим количество элементов на 12 столбцов получаем изначальное количество строк. После обновления numpy до версии 1.14.5 обязательно объявлять матрице размер типа int
	    c=(int(12)) #После обновления numpy до версии 1.14.5 обязательно объявлять матрице размер типа int
	    off.resize((cstr,c))
	    dt=off[:,0] #Используем отдельную матрицу для времени. Можно было использовать на прямую
	    dg=[] #Массив для измененных дат которые используются в матплотлиб
	    for el in dt.flat: #Цикл для создания дат формата 01, 12, 2016
		    data=(str(el)) #Переводим флоат матрицы в стринг
		    data=data.split() #Разбиваем стринг на элементы
		    tm=data[0] #Присваиваем переменной содержание данного элемента
		    elstr=tm[0:4]+' ,'+tm[4:6]+' ,'+tm[6:8] #Создаем из элемента дату в формате 01, 12, 2016
		    dg.append(elstr) # Добавляем элементы в массив..
	    xdata_float = mdates.datestr2num(dg)#Обрабатываем массив через дейтстунум для построения графиков
	    axes[i].xaxis.set_major_formatter (mdates.DateFormatter("%Y:%m")) # Для текущего графика объявляем формат используемой даты
	    axes[i].plot_date(xdata_float, off[:,9], 'b.')#Построение текущего графика
	    axes[i].tick_params(axis='x', which='major',labelsize=18) # Размер шрифта цифр подписи даты
	    axes[i].grid(True)# Разграфка
	    xtxt=[] #Массив для получения начал координат текущего графика. Используется для нанесения названий станций
	    xtxt=plt.xlim() #Копируем начала координат графика в переменную. На прямую подставлять xlim в команды нельзя изменяются масштабы
	    disx=xtxt[0]+15 #Координата x для нанесения названия станции
	    axes[i].text(disx,0.002,every[0:4],fontsize=18)#Подписи графиков из имени файлов
	    i=i+1
    fig.subplots_adjust(hspace=0)#Расстояние между графиками.
    size=fig.get_size_inches() #Получаем размер картинки
    fig.set_size_inches(size[0]*3, size[1]*4.5) #Меняем размер картинки
    plt.ylabel("dE, m")#Надпись сбоку на картинке
    plt.savefig('dE.png',format='png', dpi=250) #Сохраняем картинку
def cutting(): #Процедура подрезки полученных растров. Режет все растры с данным расширением по указанному пути. 500Х500 количество пикселов отрезаемых по бокам
    command='mogrify -shave 450X500 '+temp_dir+'/*.png' #!!!!!!
    os.popen(command) #Команда посылаемая на исполнения в командную строку терминала.
    
#Собственно сама программа
chcd(temp_dir) #меняем директорию.
stlist=lscmd() #переменная получает список файлов директории temp
openfl(stlist) #запускаем процедуру чтения файлов по списку и выделения из них данных из нужных столбцов.
plotlist=fifil() #Фильтр файлов по расширению.Отфильтрованный список присваиваем переменной которую будем использовать для обработки данных.
prep(plotlist) #Запуск процедуры для обработки данных прикручивания математики через def math
mxopen() #Фильтр файлов по расширению "mx". Список полученных файлов будем открывать и извлекать готовые матрицы для построения графиков.
cutting()
print("ГРАФИКИ СОХРАНЕНЫ")